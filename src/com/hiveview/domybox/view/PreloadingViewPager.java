package com.hiveview.domybox.view;import java.lang.reflect.Field;import android.content.Context;import android.support.v4.view.ViewPager;import android.util.AttributeSet;import android.view.animation.AccelerateDecelerateInterpolator;import android.view.animation.Interpolator;import android.widget.Scroller;public class PreloadingViewPager extends ViewPager {	private int mSelectedPageIndex = 0;		protected Context mContext;	private OnPreloadingListener listener;	private boolean isLoading = false;	//预加载的步长 	private int MAX_NUM = 2;	private boolean isScrolling;		public void setPreLoadingListener(OnPreloadingListener listener){		this.listener = listener;	}			public PreloadingViewPager(Context context, AttributeSet attrs) {		super(context, attrs);		this.mContext = context;		init();		changeViewPageScroller();	}		public PreloadingViewPager(Context context) {		super(context);		this.mContext = context;		init();		changeViewPageScroller(); 	}		private void init(){		this.setOnPageChangeListener(new MyOnPageChangeListener());	}			public interface OnPreloadingListener{		//得到当前页数		void getPagerNum(int pagerNum);				//预加载		void preLoading();				/**此方法是在状态改变的时候调用，		 * @author kylinhuang		 * @param arg0状态,ViewPager.SCROLL_STATE_SETTLING（设置完成），ViewPager.SCROLL_STATE_IDLE（闲置），ViewPager.SCROLL_STATE_DRAGGING（拖动）*/				void notifyDataSetChanged(int state);				//在下中		void loading();				/**@author kylinhuang		 * 滑动前调用的方法，		 * 默示在前一个页面滑动到后一个页面的时，在前一个页面滑动前调用的办法*/		void onPageScrolled();	}		public void stopLoading(){		if(isLoading==true){			isLoading = false;		}	}		public boolean isLoading(){		return isLoading = false;	}		private class MyOnPageChangeListener implements OnPageChangeListener{		@Override		/**此方法是在状态改变的时候调用，		 * @author kylinhuang		 *	arg0状态ViewPager.SCROLL_STATE_SETTLING（设置完成），ViewPager.SCROLL_STATE_IDLE（闲置），ViewPager.SCROLL_STATE_DRAGGING（拖动）*/				public void onPageScrollStateChanged(int arg0) {			listener.notifyDataSetChanged(arg0);		}		@Override		/**默示在前一个页面滑动到后一个页面的时辰，在前一个页面滑动前调用的办法*/		public void onPageScrolled(int arg0, float arg1, int arg2) {			if(arg2 == ViewPager.SCROLL_STATE_IDLE){				listener.onPageScrolled();			}		}		@Override		/**此方法是页面跳转完后得到调用，		 * arg0是你当前选中的页面的Position（位置编号）*/		public void onPageSelected(int arg0) {												mSelectedPageIndex = arg0;			listener.getPagerNum(mSelectedPageIndex+1);						if(PreloadingViewPager.this.getAdapter().getCount()-MAX_NUM <= mSelectedPageIndex+1&&!isLoading){				isLoading = true;							listener.preLoading();			}//			else if(PreloadingViewPager.this.getAdapter().getCount() == mSelectedPageIndex+1&&isLoading){//				listener.loading();//			}		}			}		//反射机制   控制 viewpager滑动时间  为800	private void changeViewPageScroller() {		try {			Field mField = ViewPager.class.getDeclaredField("mScroller");			mField.setAccessible(true);			FixedSpeedScroller scroller;			scroller = new FixedSpeedScroller(mContext,new AccelerateDecelerateInterpolator());			mField.set(this, scroller);		} catch (Exception e) {		}	}	class FixedSpeedScroller extends Scroller {		private int mDuration = 800;		public FixedSpeedScroller(Context context) {			super(context);		}		public FixedSpeedScroller(Context context, Interpolator interpolator) {			super(context, interpolator);		}		@Override		public void startScroll(int startX, int startY, int dx, int dy,				int duration) {			// Ignore received duration, use fixed one instead			super.startScroll(startX, startY, dx, dy, mDuration);		}		@Override		public void startScroll(int startX, int startY, int dx, int dy) {			// Ignore received duration, use fixed one instead			super.startScroll(startX, startY, dx, dy, mDuration);		}		public void setmDuration(int time) {			mDuration = time;		}		public int getmDuration() {			return mDuration;		}	};	}